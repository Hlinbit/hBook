# basic type

## Option
Option is an enum defined by the standard library. The Option type encodes the very common scenario in which a value could be something or it could be nothing.

The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.

The problem isn’t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. 

### definition
Option is an enumeration type in the Rust language, and its definition is as follows:

```
enum Option<T> {
    None,
    Some(T),
}
```

It is used to represent a value that may either exist (wrapped in Some) or not exist (None).

### exemple

In this example, we can see that Rust provides a user-friendly way to handle the unexpected result value.

```
fn find_element_index(vec: Vec<i32>, elem: i32) -> Option<usize> {
    for (index, &item) in vec.iter().enumerate() {
        if item == elem {
            return Some(index);
        }
    }
    None
}

fn main() {
    let vec = vec![10, 20, 30, 40, 50];
    match find_element_index(vec, 30) {
        Some(index) => println!("Element found at index {}", index),
        None => println!("Element not found in vec"),
    }
}

```

You have to convert an Option<T> to a T before you can perform T operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.

Another example demonstrates the usage of the specific method `take()` for `Option`. take() returns an `Option` value, and the original value is set to `None`.

```
struct Container {
    value: Option<String>,
}

impl Container {
    fn new() -> Self {
        Container { value: None }
    }
    
    fn set_value(&mut self, value: String) {
        self.value = Some(value);
    }
    
    fn take_value(&mut self) -> Option<String> {
        self.value.take()
    }
}

fn main() {
    let mut container = Container::new();
    container.set_value("Hello, world!".to_string());
    let value = container.take_value();
    println!("Taken value: {:?}", value);
    println!("Container value: {:?}", container.value);
}

\\ result:
\\ Taken value: Some("Hello, world!")
\\ Container value: None
```
## Struct

### Struct in rust

In Rust, a struct is a custom data type that allows you to group together related data fields. It is similar to a class in object-oriented programming languages, but without the inheritance and polymorphism features.

You can control the visibility of the fields in a struct by using the pub keyword. If you mark a field as pub, it can be accessed from outside the module in which the struct is defined. If you don't mark a field as pub, it is private by default and can only be accessed within the module.

### #[repr(C)] with a struct

In Rust, the #[repr(C)] attribute is used to specify the memory layout of a struct or enum in a way that is compatible with the C programming language.

```
#[repr(C)]
struct Point {
    x: i32,
    y: i32,
}
```

The use of #[repr(C)] is crucial for coding in assembly language, as it allows you to access the fields of a struct using address offsets. 

Without #[repr(C)], using address offsets to index struct fields can lead to mistakes and errors, making it difficult to work with low-level code.


### #[derive] with a struct

In Rust, the `#[derive()]` attribute is used to automatically implement common traits for a struct or an enum.

For example, the Copy and Clone traits are used to enable copying and cloning of values. 

The Ord, PartialOrd, Eq, and PartialEq traits are used for value comparison and ordering. 

```
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = p1.clone();
    
    println!("p1 == p2: {}", p1 == p2);
    println!("p1 < p2: {}", p1 < p2);
    println!("p1 > p2: {}", p1 > p2);
}
```

However, the comparison functions generated by rust compiler may not meet our demand. We can rewrite those function in `Ord, PartialOrd, Eq, and PartialEq`.

## Enum

That is, IpAddr::V4() is a function call that takes a String argument and returns an instance of the IpAddr type. We automatically get this constructor function defined as a result of defining the enum.

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```
There’s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data. Version four IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store V4 addresses as four u8 values but still express V6 addresses as one String value, we wouldn’t be able to with a struct. Enums handle this case with ease:

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```

Defining an enum with variants such as the ones in Listing 6-2 is similar to defining different kinds of struct definitions, except the enum doesn’t use the struct keyword and all the variants are grouped together under the Message type.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
```

But if we used the different structs, each of which has its own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the Message enum defined in Listing 6-2, which is a single type.

## Tuple in rust

A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```

This program first creates a tuple and binds it to the variable `tup`. It then uses a pattern with let to take tup and turn it into three separate variables, x, y, and z. This is called `destructuring` because it breaks the single tuple into three parts. Finally, the program prints the value of y, which is 6.4.

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

This program creates the tuple x and then accesses each element of the tuple using their respective indices. As with most programming languages, the first index in a tuple is 0.


## Array In rust

Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must have the same type. 

Arrays are useful when you want your data allocated on the stack rather than the heap or when you want to ensure you always have a fixed number of elements. 

However, arrays are more useful when you know the number of elements will not need to change.

The followings are some common initial ways for array.
```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
let a = [3; 5]; // contain 5 elements that will all be set to the value 3 initially.
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

When you attempt to access an element using indexing, Rust will check that the index you’ve specified is less than the array length. If the index is greater than or equal to the length, Rust will panic. This check has to happen at runtime, especially in this case, because the compiler can’t possibly know what value a user will enter when they run the code later.

# Match in rust

Rust has an extremely powerful control flow construct called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. 

## Patterns That Bind to Values

Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.

```rust 
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```



## Matching with Option<T>

```rust
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
```

## Matches Are Exhaustive

Note that the arms’ patterns must cover all possibilities. 

In this example, we didn’t handle the None case, so this code will cause a bug. 
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

Matches in Rust are exhaustive: we must exhaust every last possibility in order for the code to be valid. Especially in the case of `Option<T>`, when Rust prevents us from forgetting to explicitly handle the None case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible.

## Catch-all Patterns and the _ Placeholder

For the last arm that covers every other possible value, the pattern is the variable we’ve chosen to name other. The code that runs for the other arm uses the variable by passing it to the move_player function.

This code compiles, even though we haven’t listed all the possible values a u8 can have, because the last pattern will match all values not specifically listed. This catch-all pattern meets the requirement that match must be exhaustive.

```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
```

Note that we have to put the catch-all arm last because the patterns are evaluated in order. If we put the catch-all arm earlier, the other arms would never run, so Rust will warn us if we add arms after a catch-all!



When we no longer need to use the catch-all value, so we can change our code to use _ instead of the variable named other:

```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
```
This example also meets the exhaustiveness requirement because we’re explicitly ignoring all other values in the last arm; we haven’t forgotten anything.

## Concise Control Flow with if let

The if let syntax lets you combine if and let into a less verbose way to handle values that match one pattern while ignoring the rest. 

To satisfy the match expression, we have to add _ => () after processing just one variant, which is annoying boilerplate code to add.

```rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
```
Instead, we could write this in a shorter way using if let. The following code behaves the same as the `match`.

```rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
```

Using if let means less typing, less indentation, and less boilerplate code. In other words, you can think of if let as syntax sugar for a match that runs code when the value matches one pattern and then ignores all other values.

# Loop in rust

# `loop` loop in rust

The `loop` construct creates an infinite loop that continues until explicitly terminated with a break statement. It is commonly used when you need to repeat a block of code indefinitely or until a specific condition is met.

```
loop {
    // Code statements
    if condition {
        break; // Exit the loop
    }
    // More code statements
}
```

## `while` loop in rust

The `while` loop repeatedly executes a block of code as long as a given condition remains true. It is used when you want to continue looping based on a condition that is checked before each iteration.

```
while condition {
    // Code statements
}
```

## For loop in rust

The basic format for a for loop in Rust is as follows. It is possible to iterate over various types of variables in a for loop, such as vectors, hash maps, arrays, iterators, and more.

```
for item in sequence {
    // code to execute for each item
}
```
### `for` loop for an array.
```
let numbers = [1, 2, 3, 4, 5];
for num in numbers.iter() {
    println!("{}", num);
}
```
### `for` loop for a hash map.
```
let mut map = HashMap::new();
map.insert("key1", "value1");
map.insert("key2", "value2");
for (key, value) in &map {
    println!("{}: {}", key, value);
}
```

### How to change the value in a container.

We can use the `iter_mut()` to get a mutable iterator of elements in container.

```
let mut vector = vec![1, 2, 3];

for element in vector.iter_mut() {
    *element *= 2;
}
```

We can also access the vector by index to change the value.

```
let mut vector = vec![1, 2, 3];

for index in  0..len(vector) {
    vector[index] *= 2;
}
```

### The Difference between two loop way.

There are two common ways to implement the loop. 

```
let iterator = vec![1, 2, 3];
for element in iterator.iter() {
    println!("{}", element);
}

let v = vec![1, 2, 3];
for element in v {
    println!("{}", element);
}
```

the main difference lies in how the iterator is obtained. Using `for element in v { ... }` automatically converts the vector into an iterator, while `for element in iterator.iter() { ... } `explicitly calls the iter() method to obtain an iterator. 

### Dangerous `into_iter()`

```
let vector = vec![1, 2, 3];

for element in vector.into_iter() {
    println!("{}", element);
}
```

However, when using `into_iter()`, the vector itself will be consumed, and you won't be able to use it afterward. So be cautious when using `into_iter()` if you still need the vector in its original state after the loop.


## Iter in Rust

In Rust, an iterator is a type that represents a sequence of values that can be iterated over. Rust provides a powerful and flexible iterator trait named Iterator that defines methods for iterating over collections and other sequences of data.


The Iterator trait provides a set of methods that allow you to work with sequences of data in a functional style, such as `map`, `filter`, `fold`, `take`, `skip`, and many others. 

## Common methods for Iter

The following is an example for using `iter` and `map` for vector in rust. 

```
fn main() {
    let words = vec!["apple", "banana", "cherry"];

    let word_lengths: Vec<usize> = words.iter().map(|word| word.len()).collect();

    println!("{:?}", word_lengths);
}
```
And this is an example of combining `skip`, `filter` and `map` for iterator. This is an point that the calling chain is ended with `collect`. The `collect` method is a way to ask an iterator to perform its work and collect the results into a collection, such as a vector or a hash map. 
  
```
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let squares: Vec<i32> = numbers
        .iter()
        .skip(5) // skip the first 5 numbers
        .filter(|&num| num % 2 == 0) // filter out odd numbers
        .map(|num| num * num) // square the remaining even numbers
        .collect();

    println!("{:?}", squares);
}
```



